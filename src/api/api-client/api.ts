/* tslint:disable */
/* eslint-disable */
/**
 * DigiWF API
 * DigiWF - Plattform zur Digitalisierung von Workflows bei der LHM
 *
 * The version of the OpenAPI document: 0.34.0-SNAPSHOT
 * Contact: itm.digiwf@muenchen.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AlwMetaDataTO
 */
export interface AlwMetaDataTO {
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    extension?: string;
    /**
     * 
     * @type {string}
     * @memberof AlwMetaDataTO
     */
    contentSize?: string;
}
/**
 * 
 * @export
 * @interface ButtonTO
 */
export interface ButtonTO {
    /**
     * 
     * @type {boolean}
     * @memberof ButtonTO
     */
    showButton?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ButtonTO
     */
    buttonText?: string;
}
/**
 * 
 * @export
 * @interface ButtonsTO
 */
export interface ButtonsTO {
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    complete?: ButtonTO;
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    cancel?: ButtonTO;
    /**
     * 
     * @type {ButtonTO}
     * @memberof ButtonsTO
     */
    statusPdf?: ButtonTO;
}
/**
 * 
 * @export
 * @interface CompleteTO
 */
export interface CompleteTO {
    /**
     * 
     * @type {string}
     * @memberof CompleteTO
     */
    taskId: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CompleteTO
     */
    variables: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface ConfigEntryTO
 */
export interface ConfigEntryTO {
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigEntryTO
     */
    value: string;
}
/**
 * 
 * @export
 * @interface FollowUpTO
 */
export interface FollowUpTO {
    /**
     * 
     * @type {string}
     * @memberof FollowUpTO
     */
    taskId: string;
    /**
     * 
     * @type {string}
     * @memberof FollowUpTO
     */
    followUpDate?: string;
}
/**
 * 
 * @export
 * @interface FormFieldTO
 */
export interface FormFieldTO {
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    defaultValue?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    defaultValueField?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    prependIcon?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    tooltip?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    ext?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    multiple?: boolean;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    ldapOus?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    imageHeight?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    imageWidth?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    readonly?: boolean;
    /**
     * 
     * @type {number}
     * @memberof FormFieldTO
     */
    rows?: number;
    /**
     * 
     * @type {number}
     * @memberof FormFieldTO
     */
    col?: number;
    /**
     * 
     * @type {Array<ItemTO>}
     * @memberof FormFieldTO
     */
    items?: Array<ItemTO>;
    /**
     * 
     * @type {Array<RuleTO>}
     * @memberof FormFieldTO
     */
    rules?: Array<RuleTO>;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    itemText?: string;
    /**
     * 
     * @type {string}
     * @memberof FormFieldTO
     */
    itemValue?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FormFieldTO
     */
    returnObject?: boolean;
}
/**
 * 
 * @export
 * @interface FormTO
 */
export interface FormTO {
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof FormTO
     */
    authorizedGroups?: string;
    /**
     * 
     * @type {ButtonsTO}
     * @memberof FormTO
     */
    buttons?: ButtonsTO;
    /**
     * 
     * @type {Array<GroupTO>}
     * @memberof FormTO
     */
    groups?: Array<GroupTO>;
}
/**
 * 
 * @export
 * @interface GetAlwMetadataTO
 */
export interface GetAlwMetadataTO {
    /**
     * 
     * @type {string}
     * @memberof GetAlwMetadataTO
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GetMetadataTO
 */
export interface GetMetadataTO {
    /**
     * 
     * @type {string}
     * @memberof GetMetadataTO
     */
    url: string;
}
/**
 * 
 * @export
 * @interface GroupTO
 */
export interface GroupTO {
    /**
     * 
     * @type {string}
     * @memberof GroupTO
     */
    label?: string;
    /**
     * 
     * @type {Array<FormFieldTO>}
     * @memberof GroupTO
     */
    schema?: Array<FormFieldTO>;
}
/**
 * 
 * @export
 * @interface HistoryTask
 */
export interface HistoryTask {
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof HistoryTask
     */
    endTime?: string;
}
/**
 * 
 * @export
 * @interface HumanTaskDetailTO
 */
export interface HumanTaskDetailTO {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    processName: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    processInstanceId: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    assignee?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    assigneeFormatted?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    followUpDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskDetailTO
     */
    creationTime: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HumanTaskDetailTO
     */
    variables?: { [key: string]: object; };
    /**
     * 
     * @type {FormTO}
     * @memberof HumanTaskDetailTO
     */
    form?: FormTO;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof HumanTaskDetailTO
     */
    jsonSchema?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof HumanTaskDetailTO
     */
    statusDocument?: boolean;
}
/**
 * 
 * @export
 * @interface HumanTaskTO
 */
export interface HumanTaskTO {
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    processName?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    assignee?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    assigneeFormatted?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    followUpDate?: string;
    /**
     * 
     * @type {string}
     * @memberof HumanTaskTO
     */
    creationTime?: string;
}
/**
 * 
 * @export
 * @interface InfoTO
 */
export interface InfoTO {
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    maintenanceInfo1?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    maintenanceInfo2?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoTO
     */
    environment?: string;
}
/**
 * 
 * @export
 * @interface ItemTO
 */
export interface ItemTO {
    /**
     * 
     * @type {string}
     * @memberof ItemTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemTO
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface JsonSchemaTO
 */
export interface JsonSchemaTO {
    /**
     * 
     * @type {string}
     * @memberof JsonSchemaTO
     */
    key: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof JsonSchemaTO
     */
    schema: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface MetadataTO
 */
export interface MetadataTO {
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof MetadataTO
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface ProcessConfigTO
 */
export interface ProcessConfigTO {
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof ProcessConfigTO
     */
    statusDokument?: string;
    /**
     * 
     * @type {Array<StatusConfigTO>}
     * @memberof ProcessConfigTO
     */
    statusConfig?: Array<StatusConfigTO>;
    /**
     * 
     * @type {Array<ConfigEntryTO>}
     * @memberof ProcessConfigTO
     */
    configs?: Array<ConfigEntryTO>;
}
/**
 * 
 * @export
 * @interface RuleTO
 */
export interface RuleTO {
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    value?: string;
    /**
     * 
     * @type {string}
     * @memberof RuleTO
     */
    target?: string;
}
/**
 * 
 * @export
 * @interface SaveTO
 */
export interface SaveTO {
    /**
     * 
     * @type {string}
     * @memberof SaveTO
     */
    taskId: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof SaveTO
     */
    variables?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface SearchUserTO
 */
export interface SearchUserTO {
    /**
     * 
     * @type {string}
     * @memberof SearchUserTO
     */
    searchString?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchUserTO
     */
    ous?: string;
}
/**
 * 
 * @export
 * @interface SendMessageTO
 */
export interface SendMessageTO {
    /**
     * 
     * @type {string}
     * @memberof SendMessageTO
     */
    instanceId?: string;
    /**
     * 
     * @type {string}
     * @memberof SendMessageTO
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface ServiceDefinitionDetailTO
 */
export interface ServiceDefinitionDetailTO {
    /**
     * 
     * @type {FormTO}
     * @memberof ServiceDefinitionDetailTO
     */
    startForm?: FormTO;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ServiceDefinitionDetailTO
     */
    jsonSchema?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionDetailTO
     */
    versionTag?: string;
}
/**
 * 
 * @export
 * @interface ServiceDefinitionTO
 */
export interface ServiceDefinitionTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDefinitionTO
     */
    versionTag?: string;
}
/**
 * 
 * @export
 * @interface ServiceInstanceDetailTO
 */
export interface ServiceInstanceDetailTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    definitionName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    statusKey?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceDetailTO
     */
    description?: string;
    /**
     * 
     * @type {ProcessConfigTO}
     * @memberof ServiceInstanceDetailTO
     */
    processConfig?: ProcessConfigTO;
    /**
     * 
     * @type {Array<HistoryTask>}
     * @memberof ServiceInstanceDetailTO
     */
    historyTasks?: Array<HistoryTask>;
}
/**
 * 
 * @export
 * @interface ServiceInstanceTO
 */
export interface ServiceInstanceTO {
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    definitionName?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    startTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    endTime?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceInstanceTO
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface StartInstanceTO
 */
export interface StartInstanceTO {
    /**
     * 
     * @type {string}
     * @memberof StartInstanceTO
     */
    key?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof StartInstanceTO
     */
    variables?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface StatusConfigTO
 */
export interface StatusConfigTO {
    /**
     * 
     * @type {string}
     * @memberof StatusConfigTO
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof StatusConfigTO
     */
    label: string;
    /**
     * 
     * @type {number}
     * @memberof StatusConfigTO
     */
    position: number;
}
/**
 * 
 * @export
 * @interface StatusDokumentTO
 */
export interface StatusDokumentTO {
    /**
     * 
     * @type {string}
     * @memberof StatusDokumentTO
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StatusDokumentTO
     */
    data?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserTO
 */
export interface UserTO {
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    lhmObjectId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    forename?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    surname?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    ou?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    department?: string;
    /**
     * 
     * @type {string}
     * @memberof UserTO
     */
    email?: string;
}

/**
 * AlwDmsRestControllerApi - axios parameter creator
 * @export
 */
export const AlwDmsRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (getAlwMetadataTO: GetAlwMetadataTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAlwMetadataTO' is not null or undefined
            assertParamExists('getMetadata', 'getAlwMetadataTO', getAlwMetadataTO)
            const localVarPath = `/rest/alwdms/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAlwMetadataTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlwDmsRestControllerApi - functional programming interface
 * @export
 */
export const AlwDmsRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AlwDmsRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlwMetaDataTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(getAlwMetadataTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AlwDmsRestControllerApi - factory interface
 * @export
 */
export const AlwDmsRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AlwDmsRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetAlwMetadataTO} getAlwMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: any): AxiosPromise<AlwMetaDataTO> {
            return localVarFp.getMetadata(getAlwMetadataTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AlwDmsRestControllerApi - object-oriented interface
 * @export
 * @class AlwDmsRestControllerApi
 * @extends {BaseAPI}
 */
export class AlwDmsRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetAlwMetadataTO} getAlwMetadataTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlwDmsRestControllerApi
     */
    public getMetadata(getAlwMetadataTO: GetAlwMetadataTO, options?: any) {
        return AlwDmsRestControllerApiFp(this.configuration).getMetadata(getAlwMetadataTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DmsRestControllerApi - axios parameter creator
 * @export
 */
export const DmsRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaData: async (getMetadataTO: GetMetadataTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'getMetadataTO' is not null or undefined
            assertParamExists('getMetaData', 'getMetadataTO', getMetadataTO)
            const localVarPath = `/rest/dms/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getMetadataTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DmsRestControllerApi - functional programming interface
 * @export
 */
export const DmsRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DmsRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetaData(getMetadataTO: GetMetadataTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetadataTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetaData(getMetadataTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DmsRestControllerApi - factory interface
 * @export
 */
export const DmsRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DmsRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {GetMetadataTO} getMetadataTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetaData(getMetadataTO: GetMetadataTO, options?: any): AxiosPromise<MetadataTO> {
            return localVarFp.getMetaData(getMetadataTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DmsRestControllerApi - object-oriented interface
 * @export
 * @class DmsRestControllerApi
 * @extends {BaseAPI}
 */
export class DmsRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {GetMetadataTO} getMetadataTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DmsRestControllerApi
     */
    public getMetaData(getMetadataTO: GetMetadataTO, options?: any) {
        return DmsRestControllerApiFp(this.configuration).getMetaData(getMetadataTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DocumentRestControllerApi - axios parameter creator
 * @export
 */
export const DocumentRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDokumentForTask: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getStatusDokumentForTask', 'id', id)
            const localVarPath = `/rest/document/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentRestControllerApi - functional programming interface
 * @export
 */
export const DocumentRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatusDokumentForTask(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatusDokumentTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatusDokumentForTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentRestControllerApi - factory interface
 * @export
 */
export const DocumentRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatusDokumentForTask(id: string, options?: any): AxiosPromise<StatusDokumentTO> {
            return localVarFp.getStatusDokumentForTask(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentRestControllerApi - object-oriented interface
 * @export
 * @class DocumentRestControllerApi
 * @extends {BaseAPI}
 */
export class DocumentRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentRestControllerApi
     */
    public getStatusDokumentForTask(id: string, options?: any) {
        return DocumentRestControllerApiFp(this.configuration).getStatusDokumentForTask(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FormRestControllerApi - axios parameter creator
 * @export
 */
export const FormRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForm: async (formTO: FormTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'formTO' is not null or undefined
            assertParamExists('createForm', 'formTO', formTO)
            const localVarPath = `/rest/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getForm', 'key', key)
            const localVarPath = `/rest/form/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForms: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm: async (key: string, formTO: FormTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('updateForm', 'key', key)
            // verify required parameter 'formTO' is not null or undefined
            assertParamExists('updateForm', 'formTO', formTO)
            const localVarPath = `/rest/form/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(formTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormRestControllerApi - functional programming interface
 * @export
 */
export const FormRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createForm(formTO: FormTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createForm(formTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForm(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForms(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FormTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForms(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateForm(key: string, formTO: FormTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateForm(key, formTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FormRestControllerApi - factory interface
 * @export
 */
export const FormRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createForm(formTO: FormTO, options?: any): AxiosPromise<FormTO> {
            return localVarFp.createForm(formTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(key: string, options?: any): AxiosPromise<FormTO> {
            return localVarFp.getForm(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForms(options?: any): AxiosPromise<Array<FormTO>> {
            return localVarFp.getForms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {FormTO} formTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateForm(key: string, formTO: FormTO, options?: any): AxiosPromise<FormTO> {
            return localVarFp.updateForm(key, formTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FormRestControllerApi - object-oriented interface
 * @export
 * @class FormRestControllerApi
 * @extends {BaseAPI}
 */
export class FormRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {FormTO} formTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public createForm(formTO: FormTO, options?: any) {
        return FormRestControllerApiFp(this.configuration).createForm(formTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public getForm(key: string, options?: any) {
        return FormRestControllerApiFp(this.configuration).getForm(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public getForms(options?: any) {
        return FormRestControllerApiFp(this.configuration).getForms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {FormTO} formTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FormRestControllerApi
     */
    public updateForm(key: string, formTO: FormTO, options?: any) {
        return FormRestControllerApiFp(this.configuration).updateForm(key, formTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanTaskFileRestControllerApi - axios parameter creator
 * @export
 */
export const HumanTaskFileRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames: async (taskId: string, key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getFileNames', 'taskId', taskId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getFileNames', 'key', key)
            const localVarPath = `/rest/task/file/{taskId}/{key}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion: async (taskId: string, key: string, filename: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'taskId', taskId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'key', key)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileDeletion', 'filename', filename)
            const localVarPath = `/rest/task/file/{taskId}/{key}/{filename}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload: async (taskId: string, key: string, fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'taskId', taskId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'key', key)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getPresignedUrlForFileDownload', 'fileName', fileName)
            const localVarPath = `/rest/task/file/{taskId}/{key}/{fileName}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload: async (taskId: string, key: string, filename: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'taskId' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'taskId', taskId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'key', key)
            // verify required parameter 'filename' is not null or undefined
            assertParamExists('getPresignedUrlForFileUpload', 'filename', filename)
            const localVarPath = `/rest/task/file/{taskId}/{key}/{filename}`
                .replace(`{${"taskId"}}`, encodeURIComponent(String(taskId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"filename"}}`, encodeURIComponent(String(filename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanTaskFileRestControllerApi - functional programming interface
 * @export
 */
export const HumanTaskFileRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanTaskFileRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileNames(taskId: string, key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileNames(taskId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDeletion(taskId: string, key: string, filename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDeletion(taskId, key, filename, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileDownload(taskId: string, key: string, fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileDownload(taskId, key, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresignedUrlForFileUpload(taskId: string, key: string, filename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresignedUrlForFileUpload(taskId, key, filename, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanTaskFileRestControllerApi - factory interface
 * @export
 */
export const HumanTaskFileRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanTaskFileRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileNames(taskId: string, key: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getFileNames(taskId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDeletion(taskId: string, key: string, filename: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDeletion(taskId, key, filename, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileDownload(taskId: string, key: string, fileName: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileDownload(taskId, key, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} taskId 
         * @param {string} key 
         * @param {string} filename 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresignedUrlForFileUpload(taskId: string, key: string, filename: string, options?: any): AxiosPromise<string> {
            return localVarFp.getPresignedUrlForFileUpload(taskId, key, filename, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HumanTaskFileRestControllerApi - object-oriented interface
 * @export
 * @class HumanTaskFileRestControllerApi
 * @extends {BaseAPI}
 */
export class HumanTaskFileRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} taskId 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getFileNames(taskId: string, key: string, options?: any) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getFileNames(taskId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} key 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileDeletion(taskId: string, key: string, filename: string, options?: any) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDeletion(taskId, key, filename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} key 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileDownload(taskId: string, key: string, fileName: string, options?: any) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileDownload(taskId, key, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} taskId 
     * @param {string} key 
     * @param {string} filename 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskFileRestControllerApi
     */
    public getPresignedUrlForFileUpload(taskId: string, key: string, filename: string, options?: any) {
        return HumanTaskFileRestControllerApiFp(this.configuration).getPresignedUrlForFileUpload(taskId, key, filename, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HumanTaskRestControllerApi - axios parameter creator
 * @export
 */
export const HumanTaskRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignTask', 'id', id)
            const localVarPath = `/rest/task/assign/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelTask', 'id', id)
            const localVarPath = `/rest/task/cancel/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask: async (completeTO: CompleteTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'completeTO' is not null or undefined
            assertParamExists('completeTask', 'completeTO', completeTO)
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(completeTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUpTask: async (followUpTO: FollowUpTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'followUpTO' is not null or undefined
            assertParamExists('followUpTask', 'followUpTO', followUpTO)
            const localVarPath = `/rest/task/followup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followUpTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task/group/assigned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenGroupTasks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task/group/open`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTaskDetail', 'id', id)
            const localVarPath = `/rest/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask: async (saveTO: SaveTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'saveTO' is not null or undefined
            assertParamExists('saveTask', 'saveTO', saveTO)
            const localVarPath = `/rest/task`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saveTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HumanTaskRestControllerApi - functional programming interface
 * @export
 */
export const HumanTaskRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HumanTaskRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignTask(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelTask(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelTask(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeTask(completeTO: CompleteTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeTask(completeTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUpTask(followUpTO: FollowUpTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUpTask(followUpTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedGroupTasks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanTaskTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedGroupTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenGroupTasks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanTaskTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenGroupTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaskDetail(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HumanTaskDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaskDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTasks(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HumanTaskTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTasks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTask(saveTO: SaveTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HumanTaskDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTask(saveTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HumanTaskRestControllerApi - factory interface
 * @export
 */
export const HumanTaskRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HumanTaskRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.assignTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelTask(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelTask(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CompleteTO} completeTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTask(completeTO: CompleteTO, options?: any): AxiosPromise<void> {
            return localVarFp.completeTask(completeTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FollowUpTO} followUpTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUpTask(followUpTO: FollowUpTO, options?: any): AxiosPromise<void> {
            return localVarFp.followUpTask(followUpTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedGroupTasks(options?: any): AxiosPromise<Array<HumanTaskTO>> {
            return localVarFp.getAssignedGroupTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenGroupTasks(options?: any): AxiosPromise<Array<HumanTaskTO>> {
            return localVarFp.getOpenGroupTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskDetail(id: string, options?: any): AxiosPromise<HumanTaskDetailTO> {
            return localVarFp.getTaskDetail(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(options?: any): AxiosPromise<Array<HumanTaskTO>> {
            return localVarFp.getTasks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SaveTO} saveTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTask(saveTO: SaveTO, options?: any): AxiosPromise<HumanTaskDetailTO> {
            return localVarFp.saveTask(saveTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HumanTaskRestControllerApi - object-oriented interface
 * @export
 * @class HumanTaskRestControllerApi
 * @extends {BaseAPI}
 */
export class HumanTaskRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public assignTask(id: string, options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).assignTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public cancelTask(id: string, options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).cancelTask(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CompleteTO} completeTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public completeTask(completeTO: CompleteTO, options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).completeTask(completeTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FollowUpTO} followUpTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public followUpTask(followUpTO: FollowUpTO, options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).followUpTask(followUpTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getAssignedGroupTasks(options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).getAssignedGroupTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getOpenGroupTasks(options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).getOpenGroupTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getTaskDetail(id: string, options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).getTaskDetail(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public getTasks(options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).getTasks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SaveTO} saveTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HumanTaskRestControllerApi
     */
    public saveTask(saveTO: SaveTO, options?: any) {
        return HumanTaskRestControllerApiFp(this.configuration).saveTask(saveTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoRestControllerApi - axios parameter creator
 * @export
 */
export const InfoRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoRestControllerApi - functional programming interface
 * @export
 */
export const InfoRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InfoTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoRestControllerApi - factory interface
 * @export
 */
export const InfoRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<InfoTO> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoRestControllerApi - object-oriented interface
 * @export
 * @class InfoRestControllerApi
 * @extends {BaseAPI}
 */
export class InfoRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoRestControllerApi
     */
    public getInfo(options?: any) {
        return InfoRestControllerApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MessageControllerApi - axios parameter creator
 * @export
 */
export const MessageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage: async (sendMessageTO: SendMessageTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMessageTO' is not null or undefined
            assertParamExists('sendMessage', 'sendMessageTO', sendMessageTO)
            const localVarPath = `/rest/input/message/send/message`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMessageTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageControllerApi - functional programming interface
 * @export
 */
export const MessageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MessageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMessage(sendMessageTO: SendMessageTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMessage(sendMessageTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MessageControllerApi - factory interface
 * @export
 */
export const MessageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MessageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {SendMessageTO} sendMessageTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMessage(sendMessageTO: SendMessageTO, options?: any): AxiosPromise<void> {
            return localVarFp.sendMessage(sendMessageTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MessageControllerApi - object-oriented interface
 * @export
 * @class MessageControllerApi
 * @extends {BaseAPI}
 */
export class MessageControllerApi extends BaseAPI {
    /**
     * 
     * @param {SendMessageTO} sendMessageTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageControllerApi
     */
    public sendMessage(sendMessageTO: SendMessageTO, options?: any) {
        return MessageControllerApiFp(this.configuration).sendMessage(sendMessageTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProcessConfigurationControllerApi - axios parameter creator
 * @export
 */
export const ProcessConfigurationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfig: async (processConfigTO: ProcessConfigTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'processConfigTO' is not null or undefined
            assertParamExists('createConfig', 'processConfigTO', processConfigTO)
            const localVarPath = `/rest/processconfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processConfigTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getConfig', 'key', key)
            const localVarPath = `/rest/processconfig/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessConfigurationControllerApi - functional programming interface
 * @export
 */
export const ProcessConfigurationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProcessConfigurationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConfig(processConfigTO: ProcessConfigTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessConfigTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConfig(processConfigTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfig(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessConfigTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfig(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProcessConfigurationControllerApi - factory interface
 * @export
 */
export const ProcessConfigurationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProcessConfigurationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {ProcessConfigTO} processConfigTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConfig(processConfigTO: ProcessConfigTO, options?: any): AxiosPromise<ProcessConfigTO> {
            return localVarFp.createConfig(processConfigTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any): AxiosPromise<ProcessConfigTO> {
            return localVarFp.getConfig(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProcessConfigurationControllerApi - object-oriented interface
 * @export
 * @class ProcessConfigurationControllerApi
 * @extends {BaseAPI}
 */
export class ProcessConfigurationControllerApi extends BaseAPI {
    /**
     * 
     * @param {ProcessConfigTO} processConfigTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessConfigurationControllerApi
     */
    public createConfig(processConfigTO: ProcessConfigTO, options?: any) {
        return ProcessConfigurationControllerApiFp(this.configuration).createConfig(processConfigTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessConfigurationControllerApi
     */
    public getConfig(key: string, options?: any) {
        return ProcessConfigurationControllerApiFp(this.configuration).getConfig(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SchemaRestControllerApi - axios parameter creator
 * @export
 */
export const SchemaRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJsonSchema: async (jsonSchemaTO: JsonSchemaTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'jsonSchemaTO' is not null or undefined
            assertParamExists('createJsonSchema', 'jsonSchemaTO', jsonSchemaTO)
            const localVarPath = `/rest/jsonschema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jsonSchemaTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonSchema: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getJsonSchema', 'key', key)
            const localVarPath = `/rest/jsonschema/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaRestControllerApi - functional programming interface
 * @export
 */
export const SchemaRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SchemaRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchemaTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJsonSchema(jsonSchemaTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJsonSchema(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JsonSchemaTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJsonSchema(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SchemaRestControllerApi - factory interface
 * @export
 */
export const SchemaRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SchemaRestControllerApiFp(configuration)
    return {
        /**
         * create a new json schema
         * @param {JsonSchemaTO} jsonSchemaTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: any): AxiosPromise<JsonSchemaTO> {
            return localVarFp.createJsonSchema(jsonSchemaTO, options).then((request) => request(axios, basePath));
        },
        /**
         * get json schema by key
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJsonSchema(key: string, options?: any): AxiosPromise<JsonSchemaTO> {
            return localVarFp.getJsonSchema(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SchemaRestControllerApi - object-oriented interface
 * @export
 * @class SchemaRestControllerApi
 * @extends {BaseAPI}
 */
export class SchemaRestControllerApi extends BaseAPI {
    /**
     * create a new json schema
     * @param {JsonSchemaTO} jsonSchemaTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaRestControllerApi
     */
    public createJsonSchema(jsonSchemaTO: JsonSchemaTO, options?: any) {
        return SchemaRestControllerApiFp(this.configuration).createJsonSchema(jsonSchemaTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * get json schema by key
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaRestControllerApi
     */
    public getJsonSchema(key: string, options?: any) {
        return SchemaRestControllerApiFp(this.configuration).getJsonSchema(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceDefinitionControllerApi - axios parameter creator
 * @export
 */
export const ServiceDefinitionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinition: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getServiceDefinition', 'key', key)
            const localVarPath = `/rest/service/definition/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/service/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance: async (startInstanceTO: StartInstanceTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'startInstanceTO' is not null or undefined
            assertParamExists('startInstance', 'startInstanceTO', startInstanceTO)
            const localVarPath = `/rest/service/definition`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(startInstanceTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceDefinitionControllerApi - functional programming interface
 * @export
 */
export const ServiceDefinitionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceDefinitionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinition(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceDefinitionDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinition(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServiceDefinitions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceDefinitionTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServiceDefinitions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startInstance(startInstanceTO: StartInstanceTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startInstance(startInstanceTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceDefinitionControllerApi - factory interface
 * @export
 */
export const ServiceDefinitionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceDefinitionControllerApiFp(configuration)
    return {
        /**
         * Get a specific service definition
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinition(key: string, options?: any): AxiosPromise<ServiceDefinitionDetailTO> {
            return localVarFp.getServiceDefinition(key, options).then((request) => request(axios, basePath));
        },
        /**
         * load all available service definitions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServiceDefinitions(options?: any): AxiosPromise<Array<ServiceDefinitionTO>> {
            return localVarFp.getServiceDefinitions(options).then((request) => request(axios, basePath));
        },
        /**
         * Start a specific service
         * @param {StartInstanceTO} startInstanceTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startInstance(startInstanceTO: StartInstanceTO, options?: any): AxiosPromise<void> {
            return localVarFp.startInstance(startInstanceTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceDefinitionControllerApi - object-oriented interface
 * @export
 * @class ServiceDefinitionControllerApi
 * @extends {BaseAPI}
 */
export class ServiceDefinitionControllerApi extends BaseAPI {
    /**
     * Get a specific service definition
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public getServiceDefinition(key: string, options?: any) {
        return ServiceDefinitionControllerApiFp(this.configuration).getServiceDefinition(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * load all available service definitions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public getServiceDefinitions(options?: any) {
        return ServiceDefinitionControllerApiFp(this.configuration).getServiceDefinitions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a specific service
     * @param {StartInstanceTO} startInstanceTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceDefinitionControllerApi
     */
    public startInstance(startInstanceTO: StartInstanceTO, options?: any) {
        return ServiceDefinitionControllerApiFp(this.configuration).startInstance(startInstanceTO, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ServiceInstanceControllerApi - axios parameter creator
 * @export
 */
export const ServiceInstanceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/service/instance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getProcessInstanceDetail', 'id', id)
            const localVarPath = `/rest/service/instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceInstanceControllerApi - functional programming interface
 * @export
 */
export const ServiceInstanceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceInstanceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedInstances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ServiceInstanceTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedInstances(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProcessInstanceDetail(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceInstanceDetailTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProcessInstanceDetail(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ServiceInstanceControllerApi - factory interface
 * @export
 */
export const ServiceInstanceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceInstanceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedInstances(options?: any): AxiosPromise<Array<ServiceInstanceTO>> {
            return localVarFp.getAssignedInstances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceDetail(id: string, options?: any): AxiosPromise<ServiceInstanceDetailTO> {
            return localVarFp.getProcessInstanceDetail(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceInstanceControllerApi - object-oriented interface
 * @export
 * @class ServiceInstanceControllerApi
 * @extends {BaseAPI}
 */
export class ServiceInstanceControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceControllerApi
     */
    public getAssignedInstances(options?: any) {
        return ServiceInstanceControllerApiFp(this.configuration).getAssignedInstances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceInstanceControllerApi
     */
    public getProcessInstanceDetail(id: string, options?: any) {
        return ServiceInstanceControllerApiFp(this.configuration).getProcessInstanceDetail(id, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserRestControllerApi - axios parameter creator
 * @export
 */
export const UserRestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUser', 'id', id)
            const localVarPath = `/rest/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByUsername', 'username', username)
            const localVarPath = `/rest/user/uid/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (searchUserTO: SearchUserTO, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchUserTO' is not null or undefined
            assertParamExists('getUsers', 'searchUserTO', searchUserTO)
            const localVarPath = `/rest/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchUserTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/rest/user/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication spring_oauth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "spring_oauth", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserRestControllerApi - functional programming interface
 * @export
 */
export const UserRestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserRestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByUsername(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByUsername(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(searchUserTO: SearchUserTO, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(searchUserTO, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userinfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userinfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserRestControllerApi - factory interface
 * @export
 */
export const UserRestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserRestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(id: string, options?: any): AxiosPromise<UserTO> {
            return localVarFp.getUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUsername(username: string, options?: any): AxiosPromise<UserTO> {
            return localVarFp.getUserByUsername(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SearchUserTO} searchUserTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(searchUserTO: SearchUserTO, options?: any): AxiosPromise<Array<UserTO>> {
            return localVarFp.getUsers(searchUserTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfo(options?: any): AxiosPromise<UserTO> {
            return localVarFp.userinfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserRestControllerApi - object-oriented interface
 * @export
 * @class UserRestControllerApi
 * @extends {BaseAPI}
 */
export class UserRestControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUser(id: string, options?: any) {
        return UserRestControllerApiFp(this.configuration).getUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUserByUsername(username: string, options?: any) {
        return UserRestControllerApiFp(this.configuration).getUserByUsername(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SearchUserTO} searchUserTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public getUsers(searchUserTO: SearchUserTO, options?: any) {
        return UserRestControllerApiFp(this.configuration).getUsers(searchUserTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserRestControllerApi
     */
    public userinfo(options?: any) {
        return UserRestControllerApiFp(this.configuration).userinfo(options).then((request) => request(this.axios, this.basePath));
    }
}


